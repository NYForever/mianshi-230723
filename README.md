
# 面试资料整理


## java基础
#### [java基础](./1-jichu.md)

## 锁
#### [锁相关](./2-lock.md)

## 线程
#### [线程相关](./3-thread.md)

## 动态代理
#### [动态代理](./4-proxy.md)

## JVM虚拟机
#### [JVM虚拟机](./5-jvm.md)

## 数据库
#### [Mysql](./6-mysql.md)

#### [redis](./7-redis.md)

## 中间件
#### [kafka](./8-kafka.md)
#### [RocketMQ](./9-RocketMQ.md)

## 开源框架
### Spring
- 1.spring AOP是怎么实现的，怎么使用
- 2.spring Bean的生命周期，循环依赖spring是怎么解决的
> 在Spring容器中，Bean的创建过程经历了多个阶段，包括实例化、属性赋值、初始化和销毁等。下面是一个典型的Spring Bean的创建流程：
> 
> 1. **实例化（Instantiation）**：容器首先根据Bean定义创建一个Bean的实例。这可以通过构造函数实例化、工厂方法或其他方式来完成。这个阶段只是创建对象，但还没有进行属性注入。
> 
> 2. **属性赋值（Population of Properties）**：一旦实例化完成，容器会根据配置文件或注解进行属性注入，即将依赖的属性赋值给Bean实例。这可以通过构造函数注入、Setter方法注入或字段注入来实现。
> 
> 3. **初始化前（Initialization）**：在属性注入完成后，Spring容器会调用Bean的初始化方法（如果有定义的话）。初始化方法可以是自定义方法，也可以是实现了`InitializingBean`接口的`afterPropertiesSet`方法。此阶段可以用来执行一些预处理操作。
> 
> 4. **初始化后（Initialization）**：在初始化前阶段之后，Spring容器会执行一些后置处理操作。这包括调用实现了`BeanPostProcessor`接口的后置处理器的`postProcessBeforeInitialization`方法。
> 
> 5. **自定义初始化方法（Initialization）**：如果Bean定义中指定了自定义的初始化方法（通过配置或注解），则容器会调用这个方法。这个方法可以执行一些额外的初始化操作。
> 
> 6. **初始化后（Initialization）**：接下来，容器会再次执行后置处理操作。这次是调用实现了`BeanPostProcessor`接口的后置处理器的`postProcessAfterInitialization`方法。
> 
> 7. **Bean就绪（Ready）**：至此，Bean已经创建、初始化并准备就绪，可以供应用程序使用了。
> 
> 8. **容器关闭（Container Shutdown）**：当Spring容器关闭时，如果Bean实现了`DisposableBean`接口或定义了自定义的销毁方法，容器会调用这些方法来进行清理和资源释放操作。
> 
> 总的来说，Spring Bean的创建流程涉及了实例化、属性赋值、初始化前后处理、自定义初始化方法以及销毁等多个阶段，容器会在每个阶段执行相应的操作，确保Bean的正确创建和管理。这种创建流程使得开发人员可以集中精力于核心业务逻辑，而不必过多关注对象的初始化和销毁等细节。
- 3.spring AOP怎么实现的，和AspectJ有什么区别
- 4.spring AOP发生在Bean实力化的哪个阶段
- 5.只用二级缓存可以解决循环依赖吗
> 
> 如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，
> Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。


### Mybatis
- 1.看过源码吗？底层如何实现的？

### es
- 1.es的查询写入过程，底层实现，为什么这么设计
- 2.es集群脑裂问题，怎么产生的，怎么解决

### apollo
- 1.apollo的整体流程
```
Apollo 是一个开源的分布式配置中心，用于实现配置的集中管理和动态更新。下面是 Apollo 的整体流程：

1. 配置发布：
   - 开发人员使用 Apollo 提供的 Web 界面或 API 将配置发布到 Apollo 服务器上。
   - 发布过程会将配置存储在 Apollo 数据库中，并生成对应的配置文件。

2. 配置获取：
   - 应用程序通过 Apollo 客户端连接 Apollo 服务器，从服务器获取所需的配置信息。
   - 客户端可以根据需要指定获取的配置项、命名空间等信息。

3. 配置监听与更新：
   - Apollo 客户端在获取配置文件后会缓存在本地，并在启动时初始化配置。
   - 客户端通过长轮询或 WebSocket 等方式与 Apollo 服务器保持通信，实时监测配置变更。
   - 当配置发生变化时，Apollo 服务器会主动推送通知给客户端，客户端接收到通知后进行相应的更新操作。

4. 配置合并与生效：
   - Apollo 客户端在接收到配置更新通知后，将新的配置与本地缓存的配置进行合并。
   - 合并后的配置会覆盖原有的配置，使得配置变更生效。
   - 客户端可以根据自身需要选择何时更新配置，以最小化对业务的影响。

通过以上流程，Apollo 实现了配置的集中管理和动态更新。开发人员可以方便地使用 Apollo 进行配置的发布、获取和更新，而应用程序能够实时获取最新的配置信息，提高了配置管理的效率和灵活性。
```

### nacos&zk的区别是什么
- 1.nacos和zk的区别是什么
- 2.什么是CAP，为什么不能同时满足，redis是AP还是CP，nacos呢？zk呢？
>   ZooKeeper（zk）和 Nacos 都是分布式系统中的服务注册与发现工具，但它们在CAP理论中的定位稍有不同。
> 
> 1. **ZooKeeper（zk）**：
>    ZooKeeper 是一个分布式的协调服务，主要用于管理和维护分布式系统中的配置信息、命名服务、分布式锁等。在CAP理论中，ZooKeeper倾向于CP（一致性和分区容忍性）。它追求强一致性和数据一致性，在网络分区情况下，可能会导致某些节点无法提供服务，以保证数据的一致性。因此，ZooKeeper在某些情况下可能会牺牲可用性来实现数据一致性。
> 
> 2. **Nacos**：
>    Nacos 也是一个服务注册与发现平台，但相对于ZooKeeper，Nacos更加注重可用性，因此它更倾向于AP（可用性和分区容忍性）。Nacos可以在一定程度上容忍网络分区，保持系统的可用性，而可能在某些情况下牺牲一致性。Nacos还提供了更多功能，如动态配置管理和服务治理等。
> 
> 需要注意的是，虽然上述是一种倾向性的描述，实际上这两个工具在不同的配置和使用情境下，仍然可以进行一定程度的调整以满足不同的CAP需求。在选择工具时，您应该根据具体的业务需求和系统设计来权衡其特性，并结合实际情况做出决策。


## 分布式
- 1.

## 监控
- 1.监控的traceId是怎么传递的，怎么做到链路追踪的

## 算法
- 1.雪花算法
- 2.最长回文子串
- 3.LRU算法怎么实现
> 在 Java 中实现 LRU（Least Recently Used）算法，你可以使用 LinkedHashMap 类来简化操作。LinkedHashMap 是一个哈希表和双向链表的结合体，它提供了按照插入顺序或访问顺序迭代元素的功能。
> 
> 以下是一种基于 LinkedHashMap 的 LRU 算法实现示例：
> 
> ```java
> import java.util.LinkedHashMap;
> import java.util.Map;
> 
> public class LRUCache<K, V> extends LinkedHashMap<K, V> {
>     private int capacity;
> 
>     public LRUCache(int capacity) {
>         super(capacity, 0.75f, true);
>         this.capacity = capacity;
>     }
> 
>     @Override
>     protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
>         return size() > capacity;
>     }
>     
>     // 可以根据需要添加其他自定义方法
>     
>     public static void main(String[] args) {
>         LRUCache<Integer, String> cache = new LRUCache<>(3);
>         
>         cache.put(1, "One");
>         cache.put(2, "Two");
>         cache.put(3, "Three");
>         
>         System.out.println(cache); // 输出：{1=One, 2=Two, 3=Three}
>         
>         cache.get(2);
>         
>         cache.put(4, "Four");
>         
>         System.out.println(cache); // 输出：{2=Two, 3=Three, 4=Four}
>     }
> }
> ```
> 
> 在上述代码中，LRUCache 类继承了 LinkedHashMap 并重写了 removeEldestEntry 方法，该方法会在每次插入新元素时被调用，判断是否需要移除最旧的元素（即是否超出容量）。通过设置 LinkedHashMap 的构造函数中的 accessOrder 参数为 true，可以实现按照访问顺序进行排序。默认情况下，LinkedHashMap 按照插入顺序进行排序。
> 
> 可以根据具体需求，添加其他自定义方法来操作缓存数据。以上示例仅提供了基本的插入和访问操作的演示。

## Linux
- 1.cpu 100%怎么排查
- 2.linux大文件，怎么查看某一行的内容
> 要查看大文件中的某一行内容，可以使用以下方法：
> 
> 1. 使用`head`和`tail`命令组合：假设你要查看第1000行的内容，可以先使用`head`命令查看前1000行，然后再使用`tail`命令查看最后一行，即可得到第1000行的内容。
> 
> ```shell
> head -n 1000 filename | tail -n 1
> ```
> 
> 这个方法适用于较大的文件，因为它只需要读取文件的一部分内容。
> 
> 2. 使用`sed`命令：`sed`是一个流编辑器，在处理大文件时效率较高。通过使用`sed`命令的行定位功能，可以直接获取特定行号的内容。
> 
> ```shell
> sed -n '1000p' filename
> ```
> 
> 这个命令将输出文件中的第1000行内容。使用`-n`参数表示只输出匹配规则的行，`1000p`表示输出第1000行。
> 
> 3. 使用`awk`命令：类似于`sed`命令，`awk`也是一种强大的文本处理工具。可以使用`awk`命令来定位并输出指定行号的内容。
> 
> ```shell
> awk 'NR==1000' filename
> ```
> 
> 上述命令使用了`NR==1000`条件，表示只输出行号为1000的行。
> 
> 以上三种方法都能实现在大文件中查看指定行内容，根据个人喜好和需求选择适合的方法。
- 3.linux的常用命令有哪些

## 架构设计
- 1.高并发架构的设计思路
- 2.限流降级熔断的区别是什么
- 3.如何设计一个秒杀系统
- 4.分布式系统链路追踪，traceId怎么在不同的系统中传递，skywalking怎么做的
> 
> 可以在http head中添加key，传递traceId，每个系统有一个标识，再把该系统的标识也放在head中，就可以知道流经了哪些系统
>
>Apache SkyWalking通过使用`traceId`和`spanId`等标识符来实现分布式链路追踪。这些标识符帮助在不同的系统或服务之间传递跟踪信息，以便构建完整的调用链路。
> 
> 以下是SkyWalking实现分布式链路追踪的基本原理：
> 
> 1. **生成唯一的`traceId`：** 当一个新请求进入系统时，SkyWalking会生成一个唯一的`traceId`，标识整个请求的调用链路。
> 
> 2. **生成`spanId`：** 对于每个服务或组件，SkyWalking会为其生成一个唯一的`spanId`，用于标识该服务内部的一个操作或处理步骤。
> 
> 3. **传递标识符：** 在请求流经不同的系统或服务时，这些标识符会随着请求一起传递。传递的方式可以通过HTTP头、消息队列消息、上下文管理器等方法。
> 
> 4. **日志和数据收集：** 在每个系统或服务中，SkyWalking会在请求处理的关键点插入代码，记录相应的`traceId`、`spanId`等信息，并收集性能数据、调用关系等。
> 
> 5. **构建调用链路：** 通过在不同系统中收集到的`traceId`和`spanId`，SkyWalking可以将请求在整个分布式环境中的调用链路进行构建。这允许你看到请求在不同服务之间的流转和耗时情况。
> 
> 总的来说，SkyWalking通过在请求中添加唯一标识符并在不同的系统间传递这些标识符，实现了分布式链路追踪。这使得你可以跟踪请求在不同服务和组件之间的传递路径，以便更好地监测性能、分析问题和优化分布式系统。具体的传递方式和代码插入会根据使用的编程语言、框架以及SkyWalking的配置而有所不同。

- 5.单机演变为分布式系统，会涉及到哪些技术的调整
> 将单机系统演变为分布式系统是一个复杂的过程，涉及到许多技术和架构调整。以下是一些可能需要考虑的技术调整和变化：
> 
> 1. **架构设计：** 需要重新设计系统架构，将原本集中式的单机架构转变为分布式架构。这可能涉及到服务拆分、模块化、微服务架构等。
> 
> 2. **通信机制：** 在分布式系统中，不同服务之间需要进行远程通信。你需要选择适合的通信协议，如HTTP、RPC（Remote Procedure Call）等，以及消息队列、事件总线等通信方式。
> 
> 3. **数据存储：** 单机系统中的本地数据存储需要迁移到分布式数据库或数据存储系统，如关系数据库、NoSQL数据库、分布式文件系统等。
> 
> 4. **数据一致性：** 在分布式系统中，保持数据的一致性变得更加复杂。你需要考虑分布式事务、CAP定理、ACID属性等，以确保数据在不同节点之间保持一致性。
> 
> 5. **负载均衡：** 分布式系统需要处理更多的请求和流量。引入负载均衡技术，如软负载均衡、硬负载均衡、反向代理等，可以分摊负载并提高系统的可用性和性能。
> 
> 6. **容错和可恢复性：** 分布式系统中，节点可能会发生故障。需要考虑故障检测、容错机制、自动恢复等，以确保系统能够持续运行。
> 
> 7. **监控和调试：** 监控分布式系统的健康状况、性能瓶颈和错误是关键的。需要选择适当的监控工具和日志系统，以及实施分布式追踪技术。
> 
> 8. **安全性：** 分布式系统需要更多的安全措施，包括网络安全、身份认证、授权、数据加密等，以保护敏感数据和系统免受攻击。
> 
> 9. **部署和自动化：** 分布式系统的部署可能涉及多个节点和服务，需要自动化部署、容器化、编排等技术来简化管理和维护。
> 
> 10. **性能优化：** 分布式系统的性能优化是一个持续的过程。你需要进行负载测试、性能调优、资源管理等，以确保系统能够满足预期的性能要求。
> 
> 这些是从单机到分布式系统所涉及的一些技术调整和变化。在进行演变过程中，你需要根据系统的需求、规模和复杂性来选择合适的技术和策略，以确保分布式系统能够稳定、高效地运行。

- 6.如何设计一个秒杀系统

## 网络通讯
### grpc 

- 1.protobuf底层是什么样的
- 2.grpc为什么快
> 1.序列化方式：
> RPC服务序列化是针对二进制协议（0/1）来做序列化和反序列化，所以性能高。
> 而Http服务是基于文本的序列化和反序列化，需要读一行一行的文本（比如json格式的），进行序列化和反序列化，所以性能低。
> 
> 2.报文长度：
> RPC服务是自定义的传输协议，传输的报文都是干货。
> 而Http服务里面包括很多没用的报文内容，比如Http Header里面的accept，referer等等
> 
> 3.连接的复用：
> RPC服务是基于TCP/IP协议的，是长连接。
> 而Http服务大都是短连接，虽然Http1.1支持长连接，但是这个也是要取决于服务端是否支持长连接，不太可控。
  

### TCP
- 1.IP协议在哪一层
- 2.TCP中拥塞控制和流量控制的区别是什么
- 3.TCP和UDP的区别在哪
- 4.浏览器输入URL后，解析到页面渲染中间都发生了什么
- 5.两台服务器之间可以同时建立多条TCP链接吗，怎么实现的


## 思维拓展 & 问题实践
- 1.假如有10亿个手机号，怎么快速判断一个手机号是否在其中
- 2.如何设计一个hash函数
```
设计一��良好的哈希函数是一个复杂的任务，需要综合考虑多个因素。下面是一些常见的设计原则和技巧来设计一个好的哈希函数：

1. 均匀性：一个好的哈希函数应该尽可能地将输入数据均匀地分布到哈希值空间中，以减少冲突的概率。

2. 简单性：哈希函数应当简单且高效，以保证计算速度。

3. 一致性：对于相同的输入，哈希函数应始终返回相同的哈希值，确保数据的一致性。

4. 抗碰撞能力：哈希函数应尽量避免冲突，即不同的输入产生相同的哈希值的概率要低。

5. 扩展性：在哈希表等数据结构中，哈希函数应具有良好的扩展性，允许动态增加或删除元素而不引起大规模的哈希冲突。

6. 混淆性：哈希函数应具有较高的“混淆”能力，即使输入相差很小的情况下，其生成的哈希值也应该有较大的区别。

7. 随机性：在某些特定场景下，可以使用随机数来设计哈希函数，以增加抗碰撞能力。

8. 哈希函数的长度：哈希函数的返回值长度应根据实际需求确定。通常，较长的哈希值可以减少碰撞的概率，但会占用更多的存储空间和计算资源。

需要注意的是，设计一个完美的哈希函数往往是不可能的，因为它涉及到复杂的数学和算法问题。在实际应用中，可以根据具体场景和需求选择现有的哈希函数（如 MD5、SHA-1、CRC32等）或者根据以上原则自行设计。此外，还可以使用一些哈希函数生成器工具来辅助设计和评估哈希函数的性能和效果。
```
- 3.一个数字文件10G，jvm内存只有100m，怎么能对文件里的数字进行排序