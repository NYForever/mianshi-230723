
## 线程
- 1.线程有哪些状态，等待状态怎么产生的，死锁状态的变化过程，中止状态，interrupt()方法
```
线程在Java中有以下几种状态：

1. 新建状态（New）：当创建了一个Thread对象时，它即进入新建状态。此时线程还没有开始运行。

2. 就绪状态（Runnable）：当调用线程的start()方法后，线程进入就绪状态。此时线程已经具备执行条件，等待系统调度执行。

3. 运行状态（Running）：当线程获得CPU资源后，开始执行run()方法，线程从就绪状态切换到运行状态。

4. 阻塞状态（Blocked）：处于阻塞状态的线程暂时停止执行，直到某个条件达到才能继续执行。例如，线程在等待锁、等待输入输出、等待其他线程完成等情况下会进入阻塞状态。join可以使线程进入阻塞状态

5. 等待状态（Waiting）：线程在等待其他线程通知或者等待超时结束后进入等待状态。可以通过调用wait()和park()等方法使线程进入等待状态。

6. 计时等待状态（Timed Waiting）：与等待状态类似，但是线程会在指定的时间内自动唤醒。可以通过调用sleep()、wait()、join()和parkNanos()等方法使线程进入计时等待状态。

7. 终止状态（Terminated）：线程执行完run()方法后或者发生异常退出时，进入终止状态。

等待状态的产生：等待状态是通过调用对象的wait()、join()或者park()方法使线程进入的。这些方法会导致当前线程暂停执行，并且释放占有的资源，直到满足特定条件才能被唤醒。

死锁状态的变化过程：死锁指的是多个线程互相持有对方所需的资源而无法继续执行的状态。典型的死锁场景包括互斥、请求与保持、不可剥夺和循环等待。如果发生了死锁，线程将永远无法解除阻塞。

中止状态（Terminated）：当线程执行完run()方法，或者出现异常导致线程退出时，线程进入中止状态。该状态表示线程的生命周期已经结束，不再具备执行的条件。

interrupt()方法：interrupt()方法是Thread类提供的一个方法，用于中断线程。调用interrupt()方法会给目标线程发送中断信号，但并不会立即停止线程的执行。
如果目标线程处于阻塞状态（如sleep、wait、join等），它会收到InterruptedException异常；如果线程没有处于阻塞状态，调用interrupt()方法会设置线程的中断状态为true，
在线程的代码里可以通过isInterrupted()方法检查中断状态并做出相应处理。需要注意的是，中断只是一种协作机制，目标线程需要检测中断状态并根据情况自行终止执行。
```

- 2.Thread类有哪些常用方法
```
`Thread` 类是 Java 中用于创建和操作线程的核心类，它提供了许多常用的方法来管理线程。以下是 `Thread` 类的一些常用方法：

1. `start()`：启动线程，使其进入可运行状态并开始执行 `run()` 方法的代码。

2. `run()`：定义线程的执行逻辑，通过重写该方法来实现自定义的线程行为。

3. `sleep(long milliseconds)`：使当前线程休眠指定的时间（以毫秒为单位）。当线程休眠时，会释放 CPU 资源，但不会释放锁。

4. `join()`：等待调用此方法的线程完成，然后再继续执行后续代码。通过调用其他线程的 `join()` 方法，可以实现线程之间的顺序执行。

5. `interrupt()`：中断线程，向目标线程发送中断信号。可以通过检查线程的中断状态或捕获 `InterruptedException` 异常来响应中断信号。

6. `isInterrupted()`：检查线程是否被中断。

7. `currentThread()`：返回当前正在执行的线程对象。

8. `getName()` 和 `setName(String name)`：获取和设置线程的名称。

9. `yield()`：暂停当前线程的执行，让其他具有相同优先级的线程有机会执行。

10. `setPriority(int priority)` 和 `getPriority()`：设置和获取线程的优先级。优先级决定了线程在竞争 CPU 资源时的调度顺序。

11. `isAlive()`：检查线程是否处于活动状态（即线程已经启动但尚未终止）。

12. `getState()`：获取线程的当前状态，返回一个 `Thread.State` 枚举值，表示线程的状态，如 `NEW`、`RUNNABLE`、`BLOCKED`、`WAITING`、`TIMED_WAITING`、`TERMINATED`等。

这些方法是 `Thread` 类中常用的一部分。通过使用这些方法，可以对线程进行控制和管理，实现自定义的多线程编程逻辑。
```

- 3.ThreadLocal的原理，每个线程都有吗？用的时候需要注意什么
```
`ThreadLocal` 是 Java 中的一个线程级别的变量，它为每个线程提供独立的副本。每个线程都会拥有自己独立的 `ThreadLocal` 实例，用于存储该线程的局部变量值。以下是 `ThreadLocal` 的原理和使用注意事项：

**原理：**

`ThreadLocal` 内部维护了一个特殊的映射表，其中的键为线程对象，值为对应线程的局部变量值。当调用 `ThreadLocal` 对象的 `get()` 方法时，它会获取当前线程对应的值；而在调用 `set()` 方法时，它会设置当前线程的局部变量值。通过这种方式，每个线程都可以独立地访问和修改自己的局部变量值，互不干扰。

**每个线程都有吗？**

是的，每个线程都会拥有自己独立的 `ThreadLocal` 实例。每个线程之间的局部变量值是相互独立的，一个线程不能访问或修改另一个线程的局部变量值。

**使用注意事项：**

1. 初始化：每个线程在访问 `ThreadLocal` 变量之前，需要先初始化变量的值。可以通过覆盖 `ThreadLocal` 的 `initialValue()` 方法来指定默认值。

2. 生命周期管理：`ThreadLocal` 变量的生命周期由线程的生命周期决定。当线程结束时，`ThreadLocal` 变量也会被回收，因此不需要显示地清理 `ThreadLocal` 变量。

3. 内存泄漏：使用 `ThreadLocal` 时要注意防止内存泄漏。如果一个线程结束时，它仍然持有对 `ThreadLocal` 对象的引用，而其他线程已经无法访问到该 `ThreadLocal` 对象，那么该对象可能无法被垃圾回收。为了避免这种情况，应及时调用 `remove()` 方法来清理线程相关的数据。

4. 线程池中的使用：在使用线程池时需要特别注意 `ThreadLocal` 的使用。由于线程池中的线程可能被多个任务共享，因此在使用 `ThreadLocal` 时需要确保正确地初始化和清理变量值，以防止数据错乱。

总之，`ThreadLocal` 可以为每个线程提供独立的局部变量，并通过特殊的映射表实现。每个线程都拥有自己独立的 `ThreadLocal` 实例，用于存储局部变量值。在使用 `ThreadLocal` 时需要注意初始化、生命周期管理和避免内存泄漏等问题。
```

## 线程池
- 4.线程池的各个参数，运行逻辑；如果自己设计一个线程池要考虑哪些问题
> 
> 线程池是用于管理和复用线程的一种机制。下面我将介绍线程池的各个参数和运行逻辑，并提及自己设计线程池时需要考虑的问题。
> 
> 线程池的主要参数包括：
> 
> 1. 核心线程数（Core Pool Size）：线程池中可以同时执行的基本线程数量。
> 2. 最大线程数（Maximum Pool Size）：线程池中最多可以创建的线程数量，包括核心线程和非核心线程。
> 3. 空闲线程存活时间（Keep Alive Time）：当线程池中的线程数量超过核心线程数时，空闲线程的最长存活时间。
> 4. 阻塞队列（Blocking Queue）：用于存储等待执行的任务的队列，一般是有界队列或无界队列。
> 5. 线程工厂（Thread Factory）：用于创建新线程的工厂。
> 6. 拒绝策略（Rejected Execution Handler）：当线程池已满并且无法接受新任务时，决定如何处理被拒绝的任务。
> 
> 线程池的一般运行逻辑如下：
> 
> 1. 当提交一个新任务到线程池时，首先检查当前运行的线程数是否小于核心线程数，如果是，则创建一个新的线程来执行任务。
> 2. 如果当前运行的线程数达到或超过核心线程数，将任务放入阻塞队列中等待执行。
> 3. 如果阻塞队列已满，并且当前运行的线程数小于最大线程数，则创建一个新的非核心线程来执行任务。
> 4. 如果阻塞队列已满，并且当前运行的线程数达到最大线程数，则根据指定的拒绝策略处理被拒绝的任务。
> 
> 
> 自己设计线程池时需要考虑以下问题：
> 
> 1. 线程池大小的选择：根据应用程序的特性和负载情况，确定适当的核心线程数和最大线程数。
> 2. 阻塞队列的选择：选择适当的阻塞队列类型，如有界队列或无界队列，以及队列的容量大小，以避免资源耗尽或任务堆积。
> 3. 拒绝策略的选择：根据业务需求和线程池负载情况，选择合适的拒绝策略，例如抛出异常、丢弃任务或在调用者线程中执行任务。
> 4. 空闲线程存活时间的设置：根据应用程序的负载情况和响应时间要求，合理设置空闲线程的最长存活时间。
> 5. 线程工厂的实现：可以自定义线程工厂来创建线程，并设置线程的名称、优先级等。
> 6. 监控和调优：实时监控线程池的状态、任务执行情况和资源利用率，针对性地进行调整和优化。


- 5.线程池的拒绝策略有哪些
>
> 线程池的拒绝策略用于处理那些无法被线程池接受和处理的任务。当线程池已满并且无法接受新任务时，拒绝策略会根据配置来决定如何处理这些被拒绝的任务。以下是常见的几种拒绝策略：
> 1. **AbortPolicy（默认策略）**：该策略会直接抛出 `RejectedExecutionException` 异常，阻止新任务的提交。这是线程池默认的拒绝策略。
>
> 2. **CallerRunsPolicy**：在这个策略下，线程池将会使用调用者线程来执行被拒绝的任务。也就是说，如果线程池已满，而又有新任务提交时，不会抛弃任务，而是将任务返回给调用者线程去执行。
>
> 3. **DiscardPolicy**：该策略会默默地丢弃被拒绝的任务，并不做任何处理。即任务被简单地丢弃，不进行任何处理。
>
> 4. **DiscardOldestPolicy**：当线程池已满时，该策略会丢弃最早加入等待队列的任务，然后尝试重新提交新任务。
>
> 除了上述四种常见的拒绝策略外，Java 8 还引入了一个新的拒绝策略：
>
> 5. **AbortPolicyWithReport**：该策略类似于 AbortPolicy，但它在抛出 `RejectedExecutionException` 异常之前会先记录一条警告日志，包含被拒绝的任务信息。
>
> 选择合适的拒绝策略取决于具体业务需求和对被拒绝任务的处理。例如，如果对任务丢失不敏感，可以使用 DiscardPolicy 策略；如果希望尽量保持系统稳定，可以使用 CallerRunsPolicy 策略等。
>
> 需要根据实际场景选择合适的拒绝策略，并且根据线程池的状态、负载情况和任务特性进行评估和调整。

- 6.线程池的任务队列有哪些类型？它们的特点和适用场景是什么？LinkedBlockingQueue 不指定大小的话，是不是就不会创建新的线程来执行任务，只会等待核心线程来执行
> 
> 线程池的任务队列主要有以下几种类型：
> 
> 1. 直接交接队列（SynchronousQueue）：这是一个没有内部容量的队列，每个插入操作必须等待一个相应的移除操作。适用于负载较轻、执行时间较短的任务。
> 
> 2. 无界队列（LinkedBlockingQueue）：这是一个基于链表实现的无界队列，可以容纳任意数量的任务。当线程池中的线程已达到核心线程数时，新任务将会被放入队列中等待执行。适用于负载较重、执行时间较长、任务数量不确定的情况。
> 
> 3. 有界队列（ArrayBlockingQueue）：这是一个基于数组实现的有界队列，可以指定队列的最大容量。当线程池中的线程已达到核心线程数时，新任务将会被放入队列中等待执行。适用于限制线程池的大小和控制资源消耗的场景。
> 
> 4. 优先级队列（PriorityBlockingQueue）：这是一个基于堆结构的无界队列，任务根据优先级进行排序。适用于对任务执行顺序有严格要求的场景。
> 
> 至于 `LinkedBlockingQueue`，它是一个可选容量的无界队列。如果不指定大小，该队列可以容纳任意数量的任务。当线程池中的线程已达到核心线程数时，新任务将会被放入 `LinkedBlockingQueue` 中等待执行。因此，当任务提交速率高于核心线程处理速度时，线程池会一直等待空闲的核心线程来执行任务。
> 
> 然而，如果任务队列已满并且线程池中的线程数已达到最大线程数（即核心线程数 + 非核心线程数），则线程池会考虑创建新的线程来处理任务，前提是不超过线程池的最大线程数限制。因此，当任务提交速率持续高于核心线程的处理速度且任务队列已满时，线程池可能会创建新的线程来执行任务。
> 
> 需要注意的是，在使用无界队列时，应仔细评估任务量、系统资源和性能需求，以避免任务堆积导致内存消耗过大或性能下降的情况发生。

- 7.PriorityBlockingQueue 怎么使用，什么场景使用
> PriorityBlockingQueue 是一个基于优先级的无界队列，它用于存储实现了 Comparable 接口的元素，并根据元素的优先级进行排序。优先级高的元素在队列中被首先处理。
> 
> 使用 PriorityBlockingQueue 需要注意以下几点：
> 
> 往队列中插入的元素必须实现 Comparable 接口，以便根据元素的优先级进行排序。如果不实现 Comparable 接口，插入操作会抛出 ClassCastException 异常。
> 
> 元素的比较逻辑应该定义在 compareTo() 方法中。返回负数表示当前元素的优先级较低，返回零表示优先级相同，返回正数表示优先级较高。
>

- 8.创建线程池，指定核心线程数为5，那创建线程池时就会直接初始化5个线程池吗
```
当创建一个线程池时，指定的核心线程数为5，并不会立即初始化5个线程。线程池是按需创建和管理线程的。

根据线程池的设计原则，初始时并不会创建任何线程。只有当有任务提交到线程池时，才会根据需要动态地创建线程，直到达到核心线程数。

在这种情况下，如果没有任务提交，那么线程池中将不会有任何活动的线程。只有当任务被提交后，线程池会根据需要创建新的线程来执行任务。

因此，指定核心线程数为5只是设置了线程池的容量，表明线程池可以同时执行的基本线程数量。实际的线程创建是懒加载的，取决于任务的到达与线程池的工作负载。

值得注意的是，一旦线程池中的线程数量达到核心线程数，线程池就会保持这些线程存活，不会自动销毁，除非线程池被关闭或配置了超时机制。

总结而言，创建线程池时指定的核心线程数仅表示线程池可以同时运行的最小线程数量，而实际的线程创建和销毁是根据任务的到达和线程池的调度策略动态进行的。
```

- 9.服务器CPU为4核心，创建线程池，指定核心线程数为20，会报错吗？有用吗？
```
在创建线程池时，指定的核心线程数应该合理地与服务器资源相匹配。如果服务器只有4个核心，但指定的核心线程数为20，可能会导致以下问题：

1. 资源浪费：过多的线程数可能会导致资源浪费，因为运行的线程数量远远超过了服务器实际可用的CPU核心数。这将导致线程之间频繁切换，竞争资源，降低整体性能。

2. 过度调度开销：线程调度也需要消耗一定的时间和资源。过多的线程数会增加线程调度的开销，从而降低系统的处理能力。

3. 内存压力：每个线程都需要一定的内存空间来存储其上下文信息。过多的线程数会占用更多的内存，可能导致内存不足的问题。

因此，在这种情况下，指定核心线程数为20可能是不合适的。通常，针对一个4核心的服务器，适当选择核心线程数以充分利用服务器资源，并避免资源浪费和性能下降。

一个合理的做法是根据实际需求和负载情况来确定核心线程数，可以通过测试和性能评估来找到最佳的线程池参数配置。根据具体场景，可能需要进行一些调优和实验来找到最适合的核心线程数以达到最佳性能。

综上所述，指定过多的核心线程数可能会导致问题，并且不会提供额外的好处。在创建线程池时，应根据服务器资源和预期负载进行合理的配置。
```

- 10.线程池如何优雅地关闭和销毁？阻塞队列中的任务会怎样处理？spring中使用线程池，spring关闭，线程池中的任务如何处理
```
要优雅地关闭和销毁线程池，可以按照以下步骤进行操作：

1. 调用线程池的 `shutdown()` 方法：该方法将发送一个关闭请求给线程池，并开始逐渐停止接受新任务。

2. 对于有待执行的任务，在调用 `shutdown()` 后，线程池将等待所有已提交的任务执行完成。

3. 调用线程池的 `awaitTermination()` 方法，指定一个超时时间，等待所有正在执行的任务完成。如果超时时间内任务未完成，可以选择强制关闭线程池。

4. 调用线程池的 `shutdownNow()` 方法：该方法将尝试立即停止线程池中的所有任务，并返回队列中等待执行的任务。

5. 对于仍在阻塞队列中等待执行的任务，可以根据需求选择合适的处理方式，比如记录日志或通知相关方。

对于阻塞队列中的任务，在线程池关闭时，会根据具体的阻塞队列类型而定：

- 如果是无界队列（如 `LinkedBlockingQueue`），线程池关闭后，阻塞队列中的任务将会继续等待执行，直到被取出并执行。

- 如果是有界队列（如 `ArrayBlockingQueue`），当线程池关闭时，阻塞队列中还未被执行的任务可能会被丢弃或者抛出异常，具体取决于队列的实现方式和关闭策略。

在Spring中使用线程池时，当Spring容器关闭时，可以通过配置合适的销毁方法来处理线程池中的任务。例如，可以在Spring的 `@Bean` 注解中使用 `destroyMethod` 属性指定销毁方法。在销毁方法中，可以调用线程池的关闭方法（如 `shutdown()`），然后等待任务执行完成或强制关闭线程池。

如果有未执行的任务，可以根据需求选择合适的处理方式：

- 等待任务执行完成：可以使用线程池的 `awaitTermination()` 方法，在超时时间内等待所有任务完成。
- 强制关闭线程池：可以使用线程池的 `shutdownNow()` 方法，尝试立即停止线程池中的所有任务。

需要注意的是，为了保证线程池的正常关闭和任务的完整执行，建议在设计任务时添加相应的中断机制，确保任务能够响应中断请求，并安全地停止执行。
```

- 11.Spring中使用ThreadPoolTaskExecutor和ThreadPoolExecutor有什么区别
```
`ThreadPoolTaskExecutor`是Spring框架对`ThreadPoolExecutor`的封装和扩展，它提供了更高级的功能和更易用的配置选项。下面是`ThreadPoolTaskExecutor`和`ThreadPoolExecutor`之间的几点区别：

1. **配置方式**：`ThreadPoolTaskExecutor`可以通过Spring的配置文件（如XML配置）或基于注解（如`@EnableAsync`）来进行配置和使用。而`ThreadPoolExecutor`需要手动创建和配置。

2. **集成Spring生态系统**：`ThreadPoolTaskExecutor`是Spring框架提供的一个组件，它与其他Spring特性（如异步方法、定时任务等）集成得更加紧密。它能够与Spring的事务管理和异常处理机制无缝协作。

3. **内置的监控和管理**：`ThreadPoolTaskExecutor`提供了可扩展的监控和管理功能，例如通过Spring Actuator暴露线程池的健康指标、自动化的线程池调整（如根据负载情况动态调整线程池大小）等。而`ThreadPoolExecutor`需要自己实现这些功能。

4. **灵活的配置选项**：`ThreadPoolTaskExecutor`提供了更多的配置选项，比如队列容量、拒绝策略、线程前缀等。它还支持线程池的预热和优雅关闭等功能，使得线程池的配置更加灵活和易用。

尽管`ThreadPoolTaskExecutor`提供了更高级的功能和更易用的配置选项，但在某些情况下，可能需要直接使用`ThreadPoolExecutor`来满足特定的需求，尤其是对于一些复杂或自定义的线程池需求。
```