
- 1.聚簇索引、非聚簇索引的区别是什么，查询时有什么不同
```
聚簇索引和非聚簇索引在存储方式和查询时的表现上有一些区别：

1. 存储方式：
   - 聚簇索引：将表的行按照索引键的顺序进行排序，并且数据实际存储的物理顺序与聚簇索引的顺序一致。
   - 非聚簇索引：索引键的顺序与实际数据的物理存储顺序不一致，索引中存放了指向实际数据的指针。

2. 查询操作：
   - 聚簇索引：由于数据的物理存储顺序与索引键的顺序一致，当使用聚簇索引进行查询时，可以更快地定位到需要的数据。这使得范围查询、排序等操作更加高效。
   - 非聚簇索引：当使用非聚簇索引进行查询时，首先需要通过索引找到对应的记录的位置，然后再通过指针访问实际的数据。因此，在查询时可能需要进行两次访问：首先是根据索引查找，然后是根据指针访问实际的数据。这使得非聚簇索引在某些特定情况下（如涉及大量记录或需要访问多个列）的性能可能会稍微降低。

需要注意的是，聚簇索引和非聚簇索引在不同数据库系统中的实现可能会有所不同，因此具体的性能表现也可能存在差异。此外，根据具体的查询需求和数据访问模式，选择适当的索引策略非常重要。
```
- 2.覆盖索引是什么，数据结构是什么样的
```
覆盖索引（Covering Index）是一种特殊的索引类型，它包含了查询所需的所有字段，即索引本身已经包含了查询需要的数据，无需再对实际数据进行访问。通过创建适当的覆盖索引，可以避免额外的IO操作和数据查找，从而提高查询性能。

覆盖索引的数据结构与其他索引类型相似，通常使用B树或B+树来实现。这些树结构使得索引键值可以快速定位到所需的记录。与普通索引不同的是，覆盖索引的叶子节点上存储的不仅是索引键值，还包含了查询所需的其他列的数据。这样，在执行查询时，只需通过覆盖索引进行搜索，并从索引中直接获取所需的数据，无需回表操作。

通过使用覆盖索引，可以减少磁盘I/O和内存开销，提高查询效率。尤其在大型表或复杂查询场景下，覆盖索引能够显著降低查询的响应时间。

需要注意的是，覆盖索引并不适用于所有查询，它更适合于那些只涉及到少数列的查询。过多的包含列可能导致覆盖索引的大小变大，增加内存和磁盘的使用量。因此，在创建覆盖索引时需要权衡所需的列和性能提升之间的平衡。
```

- 3.mysql索引是越多越好吗
```
在MySQL中，索引的使用是一种权衡。虽然索引可以加快查询速度，但过多的索引也会带来一些负面影响。因此，索引的数量并不是越多越好，需要根据实际情况进行合理的设计和管理。

以下是一些需要考虑的因素：

1. 查询性能：索引可以加速数据的查找，尤其对于频繁执行的查询，适当的索引可以大幅提高性能。然而，过多的索引会增加维护成本，并可能导致额外的IO操作。因此，需要根据实际查询需求和数据访问模式选择合适的索引。

2. 写入性能：每次对表进行写操作（插入、更新、删除）时，索引也需要相应地进行更新。过多的索引会导致写操作的开销增加，因为每个索引都需要进行更新。特别是在频繁写入的情况下，过多的索引可能会拖慢写入性能。

3. 存储空间：索引会占用额外的存储空间。如果表中有大量的索引，将会占用很大的存储空间。此外，索引的大小还会影响内存的使用，因为索引通常需要加载到内存中进行查询。

4. 更新维护成本：对表的结构进行更改（如添加、修改或删除列）会涉及到索引的重新构建或更新。如果有大量的索引，这些维护操作可能会变得较为复杂和耗时。

综上所述，索引的数量需要根据具体的应用场景和需求来决定。需要权衡查询性能、写入性能、存储空间和维护成本等因素，选择适当的索引以提高整体数据库性能，并确保索引的设计和管理是有效和可持续的。
```

- 4.mysql表不指定主键会怎么样，会帮我们自动生成隐式主键吗？自动生成的主键有什么问题？
```
如果在 MySQL 表中不指定主键，MySQL 会为每一行数据生成一个隐式主键。这种隐式主键是一个自增的整数值，并且会占用额外的存储空间。

自动生成的主键可能会导致以下问题：

1. 额外存储空间消耗：隐式主键将占用额外的存储空间。对于大型表或需要频繁插入、更新和删除的表，隐式主键可能会占用较多的存储空间。

2. 主键冲突风险：由于是自动生成的，隐式主键可能存在主键冲突的风险。如果在插入数据时发生主键冲突，会导致插入失败。

3. 可读性问题：隐式主键通常是没有实际含义的数字序列，对于人类来说并不具备可读性。在某些情况下，使用具有实际含义的自定义主键可能更加直观。

4. 外键关联困难：隐式主键可能会使外键关联变得困难，因为在建立关系时无法明确使用哪个字段作为外键。

虽然 MySQL 会为没有指定主键的表生成隐式主键，但最好还是根据实际需求显式地定义适当的主键。通过手动创建主键，可以更好地控制主键的数据类型、命名和唯一性约束，并且能够根据业务需求选择合适的字段作为主键。这样可以减少存储空间消耗并提高数据的可读性和关联性。
```

- 5.mysql索引是什么数据结构，为什么不是hash B-树
```
InnoDB引擎中的索引使用的数据结构是B+树（B+ tree）。InnoDB选择B+树作为索引结构有以下原因：

1. 范围查询支持：B+树可以高效地支持按范围进行查询，这对于处理区间查询、排序和分页等操作非常重要。而哈希索引只能支持精确查找，无法进行范围查询。

2. 有序性：B+树是一种有序的数据结构，适合在磁盘上存储和访问数据。相邻的节点在物理上也是相邻存放的，利用了局部性原理，提高了磁盘I/O的效率。而哈希索引无法提供这种顺序性。

3. 磁盘存储效率：B+树适合大规模的磁盘存储，可以通过调整节点大小来充分利用磁盘块的预读能力。B+树的叶子节点包含了所有数据记录的指针，使得在进行全表扫描时非常高效。而哈希索引对于随机访问较为友好，但不适合大规模的磁盘存储。

4. 并发性能：B+树的自平衡特性使得在并发环境下更容易维护数据的一致性和完整性。并发操作之间的冲突较少，因为可以基于索引树的特性，只锁定部分节点而不是整个结构。哈希索引在并发环境下需要处理冲突和锁问题。

虽然InnoDB引擎使用B+树作为主要的索引结构，但也支持其他类型的索引，如全文索引和空间索引。选择适合场景和需求的索引类型是优化查询性能和提高数据库效率的关键。
```

- 6.事物的隔离级别有哪些？
```
MySQL支持以下四种事务隔离级别：

1. 读未提交（Read Uncommitted）：最低的隔离级别，允许一个事务读取另一个未提交的事务对数据的变更，可能导致脏读、不可重复读和幻读的问题。

2. 读已提交（Read Committed）：保证一个事务只能读取到已提交的数据，避免了脏读的问题。但是，由于其他事务可以在当前事务进行中对数据进行修改，因此可能出现不可重复读和幻读的问题。

3. 可重复读（Repeatable Read）：保证在同一个事务中多次读取相同的数据时，会返回一致性的结果。其他事务不能修改当前事务正在读取的数据，避免了脏读和不可重复读的问题。但是仍然可能出现幻读的问题。

4. 串行化（Serializable）：最高的隔离级别，在一个事务执行期间，其他事务无法对正在操作的数据进行修改或插入。保证了完全的隔离性，但可能会影响并发性能。

可重复读隔离级别不能完全避免幻读问题。幻读指的是在一个事务中多次查询同一范围内的数据，但在查询过程中有其他事务插入了新的记录，导致之前的查询看到了新插入的数据。可重复读仅通过锁定读取的记录来保证读取的一致性，而无法锁定整个范围或查询的结果集。

为了解决幻读问题，可以使用更高的隔离级别（如串行化）或其他机制，如行级锁、间隙锁或使用乐观锁处理。这些方法可以在一定程度上减少或避免幻读的发生。
```

- 7.间隙锁是什么，是前开后闭吗？能避免幻读吗
```
间隙锁（Gap Lock）是 MySQL 中一种用于解决并发事务之间的幻读问题的锁机制。它在事务期间会对一个范围的键值之间的间隙（即不存在实际数据的区域）进行加锁。

间隙锁采取了前开后闭的方式，即锁定的范围包括起始值但不包括结束值。例如，当使用 `SELECT ... FOR UPDATE` 或 `SELECT ... LOCK IN SHARE MODE` 查询时，MySQL 会在查询结果集中的记录上设置行锁，同时也会在记录之间的间隙上设置间隙锁。

间隙锁的作用是避免并发事务中的幻读问题。幻读指的是在同一个事务内执行相同的查询，但得到的结果集却不同，原因是其他事务在查询期间插入或删除了数据。

通过使用间隙锁，MySQL 可以在查询过程中阻止其他事务在范围内插入新的数据，从而保证了查询的一致性。然而，间隙锁只能防止其他事务插入新的记录，而不能阻止已有记录的更新或删除操作。

需要注意的是，间隙锁可能会导致并发性能下降，因为其他事务需要等待持有间隙锁的事务释放锁才能继续进行插入操作。因此，在设计数据库的并发访问模式时，需要权衡使用间隙锁的成本与受益，并根据具体情况进行调整。
```

- 8.InnoDB和MyISAM的区别
```
InnoDB和MyISAM是MySQL中两种常见的存储引擎，它们在功能、性能和特性上有一些区别。

以下是InnoDB和MyISAM之间的主要区别：

1. 事务支持：InnoDB是一个支持事务的存储引擎，具有ACID（原子性、一致性、隔离性、持久性）特性。它允许执行复杂的事务操作，并提供了回滚、提交和回滚日志等功能。而MyISAM不支持事务，它主要适用于读密集型应用。

2. 锁级别：InnoDB支持行级锁定，这意味着只锁定被修改的行，其他行可以并发地进行读取和修改。相比之下，MyISAM只支持表级锁定，这会导致在表上进行写操作时需要锁定整个表，限制了并发性能。

3. 数据完整性：InnoDB支持外键约束，可以确保数据的完整性。它还提供了自动故障恢复机制，包括崩溃恢复和闪回查询。MyISAM没有内置的外键支持和故障恢复机制。

4. 并发性能：由于InnoDB支持行级锁定和多版本并发控制（MVCC），它在高并发环境下的读写操作性能更好。而MyISAM在并发读取的情况下表现更好，但在并发写入时可能会出现锁冲突导致性能下降。

5. 全文搜索：MyISAM支持全文索引，提供了全文搜索的功能，而InnoDB在MySQL 5.6版本之前不支持全文索引，只能通过外部插件来实现。

6. 空间占用：一般情况下，InnoDB的数据文件相对较大，因为它支持事务和行级锁等额外功能。而MyISAM的数据文件较小，因为它没有这些额外的开销。

综上所述，InnoDB适合于需要事务支持、高并发性能和数据完整性的应用场景，如在线交易系统。而MyISAM适合于读密集型应用，如日志分析和全文搜索。选择合适的存储引擎应根据应用需求和性能要求进行评估。
```

- 9.explain关键字解析sql，各指标代表的含义
```
EXPLAIN关键字可以用于分析和解释MySQL查询语句的执行计划。它提供了查询优化器的估算信息以及相关指标，帮助我们理解查询如何被执行以及如何进行性能优化。

下面是EXPLAIN结果中各指标的常见含义：

- id：查询的编号，表示查询执行的顺序。如果查询包含子查询，则每个子查询都会有一个独立的id。
- select_type：描述了查询的类型，主要有SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION等类型。
- table：显示查询涉及的表名。
- partitions：表示查询中使用的分区（如果有）。
- type：表示访问数据的方式或连接类型，常见的类型有ALL、index、range、ref、eq_ref、const等。从最好到最差的顺序是：system > const > eq_ref > ref > range > index > ALL。
- possible_keys：表示查询可能使用的索引。
- key：表示实际使用的索引。
- key_len：表示使用的索引的长度。
- ref：表示使用的索引列与前一个表的哪个字段相关联。
- rows：表示预计需要检查的行数。
- filtered：表示在存储引擎层过滤的比例。
- Extra：额外信息，例如是否使用了临时表、排序方式、使用的索引类型等。

这些指标可以帮助我们分析查询的执行计划和性能瓶颈，进而进行优化。例如，我们可以通过检查是否使用了合适的索引、是否存在全表扫描或临时表等情况来判断查询的效率和潜在问题。

要使用EXPLAIN关键字解析一个SQL语句，只需在查询前加上EXPLAIN关键字并执行该语句即可。例如：`EXPLAIN SELECT * FROM table_name WHERE column = 'value';` 将返回查询的执行计划信息。
```

- 10.type字段 各个指标的含义，举例说明
```
在EXPLAIN结果中，"type"字段表示MySQL查询时访问数据的方式或连接类型。下面是常见的"type"指标及其含义：

1. system：通过表里只有一行的“系统”表来获取数据（仅适用于特殊情况）。

2. const：使用主键或唯一索引进行访问，只返回一行数据。这是最快的查询类型。

   例子：`SELECT * FROM table_name WHERE primary_key = value;`

3. eq_ref：对于每个表的每个联接组合，读取一个记录，并与其他表的每个匹配的记录相比较。通常出现在多表联接查询中，使用了唯一索引的等值联接。

   例子：`SELECT * FROM table1 JOIN table2 ON table1.column = table2.column WHERE table1.column = value;`

4. ref：使用非唯一索引进行访问，返回所有匹配到某个值的行。比eq_ref更高级别，但仍然是单表查询。

   例子：`SELECT * FROM table_name WHERE indexed_column = value;`

5. range：通过索引范围扫描访问部分索引中的行，通常出现在带有WHERE条件的范围查询中。

   例子：`SELECT * FROM table_name WHERE indexed_column BETWEEN value1 AND value2;`

6. index：遍历整个索引进行查找匹配的行，通常发生在覆盖索引查询（即不需要回表操作）。

   例子：`SELECT indexed_column FROM table_name WHERE indexed_column = value;`

7. all：全表扫描，检查所有的行，性能较低。应该尽量避免全表扫描。

   例子：`SELECT * FROM table_name;`

在查询优化过程中，"type"字段可以帮助我们判断查询的效率和潜在问题。一般来说，访问类型从system到all依次递减，system最好，all最差。通过优化查询语句、添加合适的索引或重新设计表结构等方法，可以改进查询的类型以提高性能。
```

- 11.mysql sql优化的方向有哪些
```
优化 MySQL 的 SQL 查询可以提高数据库的性能和响应速度。以下是一些常见的 SQL 优化方向：

1. 索引优化：
   - 确保表中的列使用了合适的索引，以加快查询速度。
   - 使用覆盖索引（Covering Index）来避免回表操作。
   - 避免在索引列上使用函数或表达式，这会阻止索引的使用。
   - 删除不再使用的索引，以减少维护开销。

2. 查询优化：
   - 编写高效的 SQL 查询语句，避免不必要的 JOIN 和子查询。
   - 使用 UNION ALL 替代 UNION，如果不需要去重。
   - 尽量限制返回的行数，使用 LIMIT 子句进行分页。
   - 避免在 WHERE 子句中使用不必要的 LIKE 操作符，可以使用全文搜索等替代方式。

3. 数据库设计优化：
   - 正确的数据库结构设计能够提高查询效率，包括合理划分表、字段类型选择、范式化与反范式化等。
   - 避免过度使用 EAV（Entity-Attribute-Value）模型，尽量采用固定模式的表结构。

4. 配置优化：
   - 调整 MySQL 的配置参数，根据硬件资源和应用需求进行优化，如缓存大小、连接数、并发数等。
   - 合理设置数据库引擎选项，选择适合应用的存储引擎（如 InnoDB、MyISAM）。

5. 语句优化：
   - 使用批量操作（如 INSERT INTO ... VALUES (...), (...), (...)）来减少与数据库的通信次数。
   - 避免在循环中频繁执行 SQL 查询，可以考虑使用 JOIN 或子查询进行一次性查询。

6. 监控和调试：
   - 使用 MySQL 的性能分析工具，如 EXPLAIN 和 SHOW PROFILES，来识别慢查询和瓶颈。
   - 监控数据库的性能指标，如查询时间、锁定情况、IO 等，以及应用程序的负载情况。

以上是一些常见的 SQL 优化方向，根据具体的场景和需求，可能还需要进一步进行针对性的优化。
```

- 12.mysql索引失效的情况
```
MySQL索引失效是指查询语句无法使用索引进行优化，导致性能下降。以下是一些常见的导致MySQL索引失效的情况：

1. 不符合索引列顺序：当查询条件中的列顺序与索引定义的列顺序不一致时，索引可能会失效。MySQL通常只能利用索引的最左前缀来执行查询。

2. 使用函数或表达式：如果在WHERE条件中使用了函数或表达式，MySQL无法直接使用索引进行匹配，导致索引失效。例如，`WHERE YEAR(date_column) = 2022`。

3. LIKE操作以通配符开头：如果在LIKE操作中使用通配符（如`LIKE '%value'`），索引将无法被利用。

4. 数据类型不匹配：当查询条件中的数据类型与索引列的数据类型不匹配时，索引可能会失效。比如将字符串和数字进行比较。

5. 使用OR操作符：对于包含OR操作符的查询，如果OR条件涉及的字段没有单独的索引，则整个查询可能无法使用索引优化。

6. 统计信息不准确：MySQL使用统计信息来估算查询成本，并选择最佳的执行计划。如果统计信息过期或不准确，可能导致MySQL做出错误的执行计划，从而使索引失效。

7. 小表全表扫描：对于非常小的表，MySQL可能会选择全表扫描而不是使用索引。这是因为索引操作需要额外的I/O开销，可能比直接读取整个表更昂贵。

8. NULL值处理：对于含有NULL值的列，索引可能会失效，因为NULL值不会被索引。

解决索引失效的方法通常包括重新设计查询语句、优化索引结构、更新统计信息、合理使用索引提示等。通过分析查询执行计划和性能指标，可以确定索引失效的原因，并采取相应的措施来提高查询性能。
```

- 13.从mysql的一次数据库事物操作操作，讲解binlog redolog undolog分别记录的数据及作用
```
在MySQL的一次数据库事务操作中，Binlog（二进制日志）、Redo Log（重做日志）和Undo Log（撤销日志）分别记录以下数据及起到的作用：

1. Binlog：
   - 数据记录：Binlog记录了对数据库进行修改的所有操作，包括插入、更新和删除语句，以及数据定义语言（DDL）语句（如表结构变更）。
   - 数据格式：Binlog以二进制格式存储，可以通过使用mysqlbinlog工具解析成可读的文本格式。
   - 作用：
     - 数据备份与恢复：通过将Binlog应用于其他数据库服务器，可以进行数据备份和恢复操作。
     - 主从复制：Binlog用于主服务器将其更改传播给从服务器，实现数据的复制和同步。
     - 数据库迁移：可以基于Binlog来迁移数据库或合并数据。

2. Redo Log：
   - 数据记录：Redo Log记录了对数据库进行的物理修改操作，包括数据页的修改和索引的更新等。
   - 数据格式：Redo Log以二进制格式存储，通常是一个预分配的固定大小的循环写入文件。
   - 作用：
     - 保证事务持久性与一致性：将事务的修改操作记录到Redo Log中，确保在数据库崩溃或故障时，可以重新执行Redo Log中的操作以保持数据的一致性。
     - 数据库恢复：通过应用Redo Log，可以将数据库从故障中恢复到最后一次提交的状态。

3. Undo Log：
   - 数据记录：Undo Log记录了事务执行过程中对数据的修改操作，包括插入、更新和删除等。
   - 数据格式：Undo Log以逻辑形式（逻辑操作）存储在回滚段（Rollback Segment）中，通常是一个事务专用的数据结构。
   - 作用：
     - 支持事务回滚：通过撤销Undo Log中的修改操作，可以回滚事务并将数据恢复到事务开始前的状态。
     - 实现多版本并发控制（MVCC）：通过读取Undo Log中的旧版本数据，实现事务之间的隔离性，避免并发事务之间的冲突。

综合来看，Binlog主要用于数据备份、恢复和主从复制；Redo Log用于保证事务的持久性和一致性，并支持数据库恢复；Undo Log用于事务回滚和实现MVCC机制。这三个日志组件共同工作，确保MySQL数据库的数据完整性、持久性，并提供高可用性、并发控制和数据恢复能力。
```

- 14.mvcc详解

```
多版本并发控制（MVCC）是一种数据库事务处理的技术，旨在提供高并发性和读取一致性的能力。MVCC允许多个事务同时读取数据库的不同版本，在不相互干扰的情况下进行并发操作。

MVCC的实现通常依赖于撤销日志（Undo Log）和版本号机制，具体步骤如下：

1. 开始事务：当一个事务开始时，会分配一个唯一的事务ID，并记录当前系统中活动的事务。

2. 生成版本号：每个数据项都有一个版本号，用于标识该数据项的时间戳或事务ID。在事务开始时，所有数据项的版本号都被复制为当前版本。

3. 修改数据：事务执行修改操作时，会生成新的数据版本，并将旧版本的数据保存到Undo Log中。新版本的数据会获得一个新的版本号，指向事务ID或时间戳。

4. 读取数据：在读取数据时，事务根据自己的事务ID或时间戳选择合适的数据版本。如果存在比当前事务更早的版本，则使用此版本，否则使用最新的版本。

5. 回滚事务：当事务回滚时，可以使用Undo Log将数据恢复到事务开始前的状态。通过撤销事务对数据的修改，可以保持数据的一致性。

MVCC的优点包括：
- 高并发性：不同事务可以同时读取数据库的不同版本，而不需要互斥地访问相同的数据项。
- 降低锁冲突：MVCC使用乐观并发控制，减少了锁的竞争，提高了并发性能。
- 读一致性：每个事务都可以看到一个一致性的视图，即使其他事务在执行修改操作。

然而，MVCC也有一些限制和注意事项：
- 存储开销：为了维护不同版本的数据，可能需要更多的存储空间。
- 长事务问题：长时间运行的事务可能导致版本链变得过长，增加数据库维护成本。
- 数据库回收：删除或更新操作会产生大量无用的旧版本数据，需要定期清理。

总体而言，MVCC是一种强大的并发控制机制，适用于高并发的数据库环境，在提供一致性和并发性方面具有重要作用。
```

- 15.为什么串行化能解决幻读
> 串行化隔离级别能够解决幻读的原因是它确保了事务的完全隔离和顺序执行。
> 
> 在串行化隔离级别下，数据库系统会为每个事务提供一个独立的执行环境，使得每个事务逐个执行，不允许并发执行。当一个事务在执行期间，其他事务必须等待该事务完成才能开始执行。
> 
> 由于串行化隔离级别下的事务串行执行，所以无论其他并发事务如何修改数据，对于正在执行的事务而言，数据是静态的，不会受到其他事务的插入、删除或修改操作的影响。
> 
> 具体来说，在串行化隔离级别下，当事务执行SELECT语句时会对涉及的数据项加上共享锁（Read Lock），这会阻塞其他事务对该数据项进行写操作。同样地，当事务执行INSERT、UPDATE或DELETE语句时，会对涉及的数据项加上排他锁（Write Lock），这会阻塞其他事务对该数据项的读写操作。
> 
> 因此，串行化隔离级别通过强制事务串行执行，确保了每个事务在执行期间对数据的唯一访问权，从而避免了幻读的问题。
> 
> 需要注意的是，串行化隔离级别会降低并发性能，因为它限制了多个事务并发执行。在高并发环境中，使用串行化隔离级别可能会导致系统性能下降。因此，在选择隔离级别时需要权衡考虑业务需求和性能要求。

- 16.select * from table where a = 1 for update 获取到的是什么锁
> 
> 当执行语句`SELECT * FROM table WHERE a = 1 FOR UPDATE`时，获取的是行级排他锁（Row-level Exclusive Lock）。
> 
> 行级排他锁是一种用于写操作的锁定机制，它可以防止其他事务并发地对同一行进行写操作。在这个例子中，`FOR UPDATE`子句表示事务希望对查询结果集中的行应用行级排他锁。
> 
> 当事务执行该语句时，将首先获取满足条件的行，并对这些行加上行级排他锁。这意味着其他事务无法同时对这些行进行修改，直到当前事务释放了这些锁。
> 
> 需要注意的是，行级排他锁不仅会阻塞其他事务的写操作，还会阻塞其他事务的读操作。这是因为行级排他锁确保了当前事务对所选行的独占访问权。其他事务在尝试读取被锁定的行时，会被阻塞，直到锁被释放。
> 
> 总结起来，`SELECT * FROM table WHERE a = 1 FOR UPDATE`语句获取的是行级排他锁，该锁会阻塞其他事务对涉及的行进行读和写操作，直到当前事务释放锁。这种方式可用于实现悲观并发控制，确保事务之间的数据一致性。
> 
> 在xxljob中就是用了这样的机制，分布式的部署xxljob，只有一台机器去获取要执行的任务，相当于分布式锁；同一时间只有一台机器能获取到锁，然后事务不提交，在事务内进行逻辑操作
> 

- 17.一个mysql10亿条数据，怎么分页查询第20页的数据

- 18.可重复度隔离级别下，避免了哪些情况的幻读，避免不了哪些情况的幻读
> MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：
> 
> 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。
> 
> 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。
> 
> 我举例了两个发生幻读场景的例子。
> 
> 第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。
> 
> 第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。
> 
> 所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。
> 
> 要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。