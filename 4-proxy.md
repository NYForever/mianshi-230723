
- 1.jdk动态代理和cglib的区别什么，实现原理是什么
>
> JDK动态代理和CGLIB是两种常用的Java动态代理技术，它们在实现原理和使用方式上存在一些区别。
> 
> **JDK动态代理：**
> - 基于接口的代理技术，要求目标类必须实现接口。
> - 使用`java.lang.reflect.Proxy`类和`java.lang.reflect.InvocationHandler`接口来创建代理对象。
> - 在运行时动态创建一个实现了目标接口的代理类，代理类中的方法会被重定向到InvocationHandler对象上。
> - JDK动态代理通过反射机制创建代理对象，对目标接口的方法进行增强。
> - JDK动态代理只能代理实现了接口的类，不能代理没有实现接口的类。
> 
> **CGLIB动态代理：**
> - 基于继承的代理技术，可以代理没有实现接口的类。
> - 使用字节码生成框架`ASM`来操作字节码并生成代理类。
> - 在运行时动态创建目标类的子类，将代理逻辑织入到子类的方法中。
> - CGLIB动态代理通过继承实现代理，对目标类的方法进行增强。
> - CGLIB动态代理不能代理被标记为`final`的类和方法。
> 
> **实现原理：**
> - JDK动态代理是基于接口的代理，通过创建代理类实现目标接口，并在代理类中调用InvocationHandler的invoke方法来处理方法调用。
> - CGLIB动态代理是基于继承的代理，通过创建目标类的子类，并在子类中重写目标方法，在重写的方法中添加代理逻辑。
> 
> 总结来说，JDK动态代理适合代理接口的情况，而CGLIB动态代理适合代理没有实现接口的类。由于JDK动态代理使用Java原生的反射机制，因此它的性能通常比CGLIB动态代理要高一些。然而，如果目标类没有实现接口，则只能使用CGLIB动态代理。


- 2.哪些项目中真正使用了动态代理，怎么用的
> 
> 动态代理在许多项目中被广泛使用，以下是一些常见的应用场景和用法示例：
> 
> 1. Spring框架：Spring框架中的AOP（面向切面编程）功能就是基于动态代理实现的。通过配置切点和通知，Spring可以在目标方法执行前、后或抛出异常时插入自定义逻辑。使用动态代理，Spring能够在运行时为目标对象生成代理对象，并将通知逻辑织入到代理对象中。
> 
> 2. Hibernate框架：Hibernate是一个ORM（对象关系映射）框架，它使用动态代理技术来实现延迟加载（Lazy Loading）。当访问一个懒加载属性时，Hibernate会通过动态代理生成一个代理对象，在首次访问属性时才加载相关数据。
> 
> 3. Mockito测试框架：Mockito是一个流行的Java测试框架，它使用动态代理来创建模拟对象（mock objects）。模拟对象可以替代真实对象，用于测试代码的行为是否符合预期。
> 
> 4. RPC框架：远程过程调用（RPC）框架如Dubbo和gRPC等也使用了动态代理技术。这些框架可以根据接口定义，在客户端和服务器之间自动生成代理对象和远程调用代码，使得开发人员可以像调用本地方法一样调用远程方法。
> 
> 在使用动态代理时，一般的步骤如下：
> 
> 1. 定义接口：为要代理的类定义一个接口，在接口中声明需要被代理的方法。
> 
> 2. 实现InvocationHandler接口：创建一个实现InvocationHandler接口的类，该类中实现invoke方法，在invoke方法中添加对目标方法的增强逻辑。
> 
> 3. 创建代理对象：使用Proxy类的静态方法newProxyInstance创建代理对象。该方法接受三个参数：ClassLoader、接口数组和InvocationHandler对象。
> 
> 4. 调用代理对象方法：通过代理对象调用方法，实际上会触发InvocationHandler的invoke方法，在其中执行增强逻辑。
> 
> 具体的实现代码会因项目和框架的不同而有所差异，以上只是一般的使用流程。无论是Spring、Hibernate还是其他框架，动态代理都能够以一种优雅且灵活的方式来解决各种问题。